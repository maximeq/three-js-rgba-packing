<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - simple global illumination</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			#info {
				top: 5px;
				width: 100%;
				font-family:Monospace;
				font-size:13px;
				font-weight: bold;
				text-align: center;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Packing Numbers in RGBA Textures
		</div>
        <hr>
        <div id="unit-float32-javascript-results">
        </div>
        <hr>
        <div id="unit-float32-gpu-results">
        </div>

        <script src="../node_modules/three-full/builds/Three.iife.js"></script>
        <script>
            // Alias to use Three-full as Three
            var THREE = THREE || Three;
        </script>
        <script src="../dist/browser/three-js-rgba-packing.js"></script>

		<script>

            var rgba = new Float32Array([0,0,0,0]);
            var f32 = new Float32Array([0]);
            var f32dec = new Float32Array([0]);

            // Maximum difference found bewteen encode/decode
            var max_diff = 0;

            // Test on javascript side
            var n_js_tests = 1000;
            for(var i=0; i<2048; ++i){
                f32[0] = Math.min(Math.random(),1-1e-7);
                THREERGBAPacking.encodeUnitFloat32(f32[0], rgba);
                f32dec[0] = THREERGBAPacking.decodeUnitFloat32(rgba);
                var diff = f32[0] - f32dec[0];
                if( diff !== 0){
                    if(diff > max_diff){
                        max_diff = diff;
                    }
                }
            }
            document.getElementById('unit-float32-javascript-results').innerHTML = "Tested Javascript encodeUnitFloat32 / decodeUnitFloat32 on "+ n_js_tests + " numbers. Maximum found difference was : "+max_diff;

            // Test on GPU
            var wh = 128;
            var size = wh * wh;
            var f32_data = new Float32Array(size);
            var data = new Uint8Array( 4 * size );

            var rgba = new Float32Array([0,0,0,0]);
            for ( var i = 0; i < size; i ++ ) {
                f32_data[i] = Math.random();
                THREERGBAPacking.encodeUnitFloat32(f32_data[i], rgba);

                data[ 4*i ] = Math.round(rgba[0]*255);
                data[ 4*i + 1 ] = Math.round(rgba[1]*255);
                data[ 4*i + 2 ] = Math.round(rgba[2]*255);
                data[ 4*i + 3 ] = Math.round(rgba[3]*255);
            }

            // used the buffer to create a DataTexture
            var texture = new THREE.DataTexture( data, wh, wh, THREE.RGBAFormat );
            texture.needsUpdate = true;

            var rt = new THREE.WebGLRenderTarget( wh, wh, {
                wrapS: THREE.RepeatWrapping,
                wrapT: THREE.RepeatWrapping,
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                depthBuffer: true,
                format: THREE.RGBAFormat
            });
            var scene = new THREE.Scene();
            var mesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(wh,wh,1,1),
                new THREE.ShaderMaterial(
                    {
                        uniforms: {
                            uTexture : {
                                type : 't',
                                value: texture
                            }
                        },
                        vertexShader:   [
                            "varying vec2 vUv;",
                            "void main ()",
                            "{",
                            "   vUv = uv;",
                            "   gl_Position = projectionMatrix * modelViewMatrix  * vec4(position,1.);",
                            "}"
                        ].join("\n"),
                        fragmentShader: [
                            "varying vec2 vUv;",
                            "uniform sampler2D uTexture;",
                            THREERGBAPacking.glslEncodeUnitFloat32,
                            THREERGBAPacking.glslDecodeUnitFloat32,
                            "void main ()",
                            "{",
                            "  vec4 texel = texture2D(uTexture, vec2(vUv.x, vUv.y));",
                            "  float f = decodeUnitFloat32(texel);",
                            "  vec4 finalColor = encodeUnitFloat32(f);",
                            "  gl_FragColor = finalColor;",

                            "}"
                        ].join("\n")
                    }
                )
            );
            var cam = new THREE.OrthographicCamera(-wh/2,wh/2,wh/2,-wh/2,-1000,1000);
            var buffer = new Uint8Array( wh*wh*4 );

            scene.updateMatrixWorld( true );
            scene.add(mesh);

            var renderer = new THREE.WebGLRenderer({alpha:true, antialias:false});

            renderer.setRenderTarget(rt);
            renderer.setClearColor( new THREE.Color(1,1,1), 0.0);
            renderer.clear();
            renderer.render( scene, cam, rt );
            renderer.readRenderTargetPixels( rt, 0, 0, wh, wh, buffer );

            // Test the difference between values sent
            max_diff = 0;
            for(var i=0; i<size; ++i){
                rgba[0] = buffer[4*i]/255;
                rgba[1] = buffer[4*i+1]/255;
                rgba[2] = buffer[4*i+2]/255;
                rgba[3] = buffer[4*i+3]/255;

                f32dec[0] = THREERGBAPacking.decodeUnitFloat32(rgba);
                var diff = Math.abs(f32dec[0] - f32_data[i]);
                if(diff > max_diff){
                    max_diff = diff;
                }
            }

             document.getElementById('unit-float32-gpu-results').innerHTML = "Tested GLSL encodeUnitFloat32 / decodeUnitFloat32 on "+ (wh*wh) + " numbers. Maximum found difference was : "+max_diff;

		</script>

	</body>
</html>
